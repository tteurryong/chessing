<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>픽셀 로또 추첨기 (2D)</title>
<style>
  :root{--bg:#0b1020;--panel:#111426;--muted:#91a0d6;--accent:#7aa2ff}
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#eaf0ff}
  .wrap{max-width:1100px;margin:18px auto;padding:18px;display:grid;grid-template-columns:360px 1fr;gap:18px}
  .panel{background:linear-gradient(180deg,#0f1530,#0b1020);border:1px solid rgba(255,255,255,0.04);padding:12px;border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
  h1{margin:0 0 8px;font-size:20px}
  label{display:block;font-size:13px;color:var(--muted);margin-top:8px}
  input[type=number],select{width:100%;padding:8px;border-radius:8px;border:0;background:#0c1230;color:inherit}
  button{margin-top:8px;padding:10px 12px;border-radius:10px;border:0;background:var(--accent);color:#08132a;font-weight:700;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  #canvasWrap{display:grid;place-items:center}
  canvas{image-rendering: pixelated; background: linear-gradient(180deg,#071028,#0b1020); border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,0.6)}
  .controls-row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .footer{font-size:12px;color:var(--muted);margin-top:8px}
  pre{white-space:pre-wrap;word-break:break-word}
</style>
</head>
<body>
  <div class="wrap">
    <div class="panel" aria-label="설정">
      <h1>픽셀 로또 추첨기 (2D)</h1>
      <div class="footer">중복 없이 · 순서 무관 · 보안난수(window.crypto) 사용</div>

      <label>세트 개수</label>
      <input id="count" type="number" min="1" max="50" value="3"/>

      <label><input id="bonus" type="checkbox" checked/> 보너스 포함</label>

      <label>픽셀 해상도 (작을수록 픽셀풍)</label>
      <select id="pixelSize">
        <option value="8">8px (강한 픽셀)</option>
        <option value="6" selected>6px</option>
        <option value="4">4px (덜 픽셀)</option>
      </select>

      <div class="controls-row">
        <button id="genBtn">생성 (애니메이션)</button>
        <button id="instantBtn" class="ghost">즉시 생성</button>
      </div>

      <div class="controls-row">
        <button id="copyBtn" class="ghost" disabled>텍스트 복사</button>
        <button id="exportBtn" class="ghost" disabled>JSON 내보내기</button>
        <button id="clearBtn" class="ghost" disabled>모두 지우기</button>
      </div>

      <div class="footer">최근 결과:</div>
      <pre id="recent" style="height:86px;overflow:auto;background:#06061a;padding:8px;border-radius:8px;margin-top:6px"></pre>

      <div class="footer">설치 팁: GitHub Pages(HTTPS)에서 열면 사운드가 더 잘 동작합니다.</div>
    </div>

    <div id="canvasWrap" class="panel">
      <canvas id="screen"></canvas>
      <div style="position:relative;width:100%;max-width:820px;margin-top:12px;color:var(--muted);text-align:center">
        <div id="resultText" style="font-weight:800;letter-spacing:0.6px"></div>
      </div>
    </div>
  </div>

<script>
/* ====== 설정 & DOM ====== */
const canvas = document.getElementById('screen');
const ctx = canvas.getContext('2d');
const off = document.createElement('canvas'); // 저해상도 캔버스 (픽셀화용)
const offCtx = off.getContext('2d');

const genBtn = document.getElementById('genBtn');
const instantBtn = document.getElementById('instantBtn');
const copyBtn = document.getElementById('copyBtn');
const exportBtn = document.getElementById('exportBtn');
const clearBtn = document.getElementById('clearBtn');
const recentEl = document.getElementById('recent');
const resultText = document.getElementById('resultText');

const countEl = document.getElementById('count');
const bonusEl = document.getElementById('bonus');
const pixelSizeEl = document.getElementById('pixelSize');

const STORAGE_KEY = 'pixel-lotto-v1';

/* ====== 오디오 (간단 합성) ====== */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function ensureAudio(){
  if(!audioCtx) audioCtx = new AudioCtx();
  if(audioCtx.state==='suspended') audioCtx.resume();
}
function playClick(){
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'square';
  o.frequency.value = 900;
  g.gain.value = 0.18;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.08);
  o.stop(audioCtx.currentTime + 0.09);
}
function playPop(){
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.value = 400;
  g.gain.value = 0.25;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.12);
  o.stop(audioCtx.currentTime + 0.13);
}

/* ====== 렌더 설정 (픽셀 배율) ====== */
function resizeCanvas(){
  const pixel = Number(pixelSizeEl.value) || 6;
  // offscreen size: width x height in "pixels"
  const W = 120, H = 72; // 작은 픽셀 캔버스
  off.width = W; off.height = H;
  // scaled to screen: each pixel = pixel px
  canvas.width = W * pixel;
  canvas.height = H * pixel;
  canvas.style.width = canvas.width + 'px';
  canvas.style.height = canvas.height + 'px';
  // set smoothing off for pixelated look
  ctx.imageSmoothingEnabled = false;
  offCtx.imageSmoothingEnabled = false;
}
pixelSizeEl.addEventListener('change', resizeCanvas);
resizeCanvas();

/* ====== 시뮬레이션: 공(2D 원) + 간단 충돌 ====== */
const world = {
  balls: [], // {x,y,vx,vy,r,num,color,removed}
  particles: [], // simple particle sparks
  width: off.width, height: off.height,
  drum: {cx: off.width/2, cy: off.height/2 - 6, r: Math.min(off.width, off.height)*0.34},
  state:'idle'
};

function randInt(max){ // crypto-safe int
  const a = new Uint32Array(1); window.crypto.getRandomValues(a);
  return Math.floor(a[0] / 0xFFFFFFFF * max);
}
function cryptoPick6(){
  // reservoir-like removal using crypto: create pool and pick
  const pool = Array.from({length:45}, (_,i)=>i+1);
  const chosen = [];
  for(let k=0;k<6;k++){
    const idx = Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0] / 0xFFFFFFFF * pool.length);
    chosen.push(pool.splice(idx,1)[0]);
  }
  return chosen.sort((a,b)=>a-b);
}

/* 색상 (국내 로또風) */
function ballColor(n){
  if(n<=10) return [255,211,77];
  if(n<=20) return [106,168,255];
  if(n<=30) return [255,122,122];
  if(n<=40) return [183,192,209];
  return [98,210,162];
}

/* 생성 및 초기화 */
function spawnBallsForNumbers(nums){
  world.balls.length = 0;
  const {cx,cy,r} = world.drum;
  for(let i=0;i<nums.length;i++){
    const num = nums[i];
    const angle = Math.random()*Math.PI*2;
    const rr = Math.random()*(r-4);
    const x = Math.floor(cx + Math.cos(angle)*rr);
    const y = Math.floor(cy + Math.sin(angle)*rr);
    const speed = 0.6 + Math.random()*1.4;
    const dir = Math.random()*Math.PI*2;
    const vx = Math.cos(dir)*speed;
    const vy = Math.sin(dir)*speed;
    world.balls.push({
      x,y,vx,vy,r:3.6, num, removed:false, color:ballColor(num), angle:0, spin: (Math.random()-0.5)*0.25
    });
  }
}

/* 단순 충돌 처리 (공-공) */
function stepPhysics(dt){
  const damp = 0.996;
  const {cx,cy,r} = world.drum;
  // integrate
  for(const b of world.balls){
    if(b.removed) continue;
    b.vy += 0.12 * dt; // pseudo gravity
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.vx *= damp; b.vy *= damp;
    b.angle += b.spin * dt;
    // wall (circular) collision
    const dx = b.x - cx, dy = b.y - cy;
    const dist = Math.hypot(dx,dy);
    const limit = r - b.r;
    if(dist > limit){
      // push inward & reflect velocity
      const nx = dx / dist, ny = dy / dist;
      const penetration = dist - limit;
      b.x -= nx*penetration; b.y -= ny*penetration;
      const vdotn = b.vx*nx + b.vy*ny;
      b.vx -= 1.9 * vdotn * nx; b.vy -= 1.9 * vdotn * ny;
      // spawn tiny particles & sound
      spawnParticles(b.x, b.y, 6);
      playClick();
    }
  }
  // pairwise collisions
  for(let i=0;i<world.balls.length;i++){
    const a = world.balls[i];
    if(a.removed) continue;
    for(let j=i+1;j<world.balls.length;j++){
      const b = world.balls[j];
      if(b.removed) continue;
      const dx = b.x - a.x, dy = b.y - a.y;
      const d2 = dx*dx + dy*dy;
      const minDist = a.r + b.r;
      if(d2 < minDist*minDist && d2>0.0001){
        const d = Math.sqrt(d2);
        const nx = dx/d, ny = dy/d;
        const overlap = 0.5*(minDist - d + 0.01);
        a.x -= nx*overlap; a.y -= ny*overlap;
        b.x += nx*overlap; b.y += ny*overlap;
        // relative velocity along normal
        const rvx = b.vx - a.vx, rvy = b.vy - a.vy;
        const sepVel = rvx*nx + rvy*ny;
        if(sepVel < 0){
          const impulse = - (1.9 * sepVel) / 2;
          a.vx -= impulse * nx; a.vy -= impulse * ny;
          b.vx += impulse * nx; b.vy += impulse * ny;
          spawnParticles((a.x+b.x)/2, (a.y+b.y)/2, 4);
          playClick();
        }
      }
    }
  }
  // update particles
  for(let i=world.particles.length-1;i>=0;i--){
    const p = world.particles[i];
    p.x += p.vx*dt; p.y += p.vy*dt; p.life -= dt*1000;
    p.vy += 0.18 * dt;
    if(p.life <= 0) world.particles.splice(i,1);
  }
}

/* 파티클 생성 */
function spawnParticles(x,y,count=8){
  for(let i=0;i<count;i++){
    world.particles.push({
      x:+x, y:+y,
      vx:(Math.random()-0.5)*1.6, vy:(Math.random()-0.9)*1.8,
      life: 420 + Math.random()*220,
      color: (Math.random()<0.5? [200,200,255] : [230,230,230])
    });
  }
}

/* ====== 드로잉 (픽셀화 위해 offscreen 사용) ====== */
function render(){
  // offscreen clear
  offCtx.clearRect(0,0,off.width,off.height);
  // background inside drum
  const {cx,cy,r} = world.drum;
  offCtx.fillStyle = '#08102a';
  offCtx.fillRect(0,0,off.width,off.height);
  // drum circle
  offCtx.beginPath(); offCtx.fillStyle = '#0e1a3a'; offCtx.arc(cx,cy,r,0,Math.PI*2); offCtx.fill();
  // draw particles
  for(const p of world.particles){
    offCtx.fillStyle = `rgb(${p.color[0]},${p.color[1]},${p.color[2]})`;
    offCtx.fillRect(Math.round(p.x)-1, Math.round(p.y)-1, 2,2);
  }
  // draw balls (simple pixel circle with outline)
  for(const b of world.balls){
    if(b.removed) continue;
    const x = Math.round(b.x), y = Math.round(b.y);
    const c = b.color;
    // fill
    offCtx.fillStyle = `rgb(${c[0]},${c[1]},${c[2]})`;
    // simple disc using filled rects (pixel look)
    const s = Math.round(b.r);
    for(let yy=-s; yy<=s; yy++){
      for(let xx=-s; xx<=s; xx++){
        if(xx*xx+yy*yy <= s*s) offCtx.fillRect(x+xx, y+yy, 1,1);
      }
    }
    // number as tiny font (white)
    offCtx.fillStyle = '#081027';
    offCtx.font = '6px monospace';
    offCtx.textAlign = 'center';
    offCtx.textBaseline = 'middle';
    offCtx.fillText(String(b.num).padStart(2,'0'), x, y);
  }
  // upscale to visible canvas
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(off, 0,0, off.width, off.height, 0,0, canvas.width, canvas.height);
  ctx.restore();
}

/* ====== 추첨 애니메이션 로직 ====== */
async function animateDrawSequence(nums, includeBonus){
  world.state = 'running';
  // spawn balls for all numbers (main + maybe bonus if separately)
  spawnBallsForNumbers(nums);
  resultText.textContent = '';
  recentLogPush(nums, includeBonus ? nums[nums.length-1] : null);
  // spin for a while (let physics run)
  let spinTime = 1300 + Math.random()*900;
  const start = performance.now();
  while(performance.now() - start < spinTime){
    stepPhysics(1);
    render();
    await tick();
  }
  // pick out one by one visually: find ball by number, mark removed and animate moving outward
  for(let i=0;i<nums.length;i++){
    const n = nums[i];
    // find ball object
    const b = world.balls.find(x=>x.num === n && !x.removed);
    if(!b) continue;
    // animate move outward to top-center rack area
    const targetX = off.width*0.5; const targetY = off.height*0.10 + i*6;
    // perform simple tween
    const frames = 28;
    const sx = (targetX - b.x)/frames, sy = (targetY - b.y)/frames;
    for(let f=0; f<frames; f++){
      b.x += sx; b.y += sy;
      b.vx *= 0.6; b.vy *= 0.6;
      stepPhysics(1);
      render();
      await tick();
    }
    // finalize: mark removed and spawn pop sound+particles
    b.removed = true;
    spawnParticles(b.x, b.y, 20);
    playPop();
    render();
    await delay(220);
  }
  // done
  resultText.textContent = formatResult(nums, includeBonus);
  world.state = 'idle';
  updateButtons();
}

/* small helpers */
function tick(){ return new Promise(resolve => requestAnimationFrame(()=>resolve())); }
function delay(ms){ return new Promise(res=>setTimeout(res, ms)); }
function formatResult(main, includeBonus){ 
  // main is array (if includeBonus true last element is bonus)
  if(includeBonus){
    const bonus = main[main.length-1];
    const mains = main.slice(0,6).sort((a,b)=>a-b);
    return mains.join(', ') + '  (+ ' + String(bonus).padStart(2,'0') + ')';
  } else {
    return main.slice(0,6).sort((a,b)=>a-b).join(', ');
  }
}

/* ====== 로컬 저장/최근 로그 ====== */
function persistHistory(entry){
  try{
    const arr = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
    arr.unshift(entry);
    if(arr.length>30) arr.length = 30;
    localStorage.setItem(STORAGE_KEY, JSON.stringify(arr));
    renderRecent();
  }catch(e){}
}
function renderRecent(){
  try{
    const arr = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
    recentEl.textContent = arr.slice(0,8).map((it,idx)=> `${idx+1}. ${it.text} (${it.ts})`).join('\\n') || '아직 기록 없음';
  }catch(e){ recentEl.textContent = '불러오기 실패'; }
}
function recentLogPush(nums, bonus){
  const ts = new Date().toLocaleString();
  const text = formatResult(nums, !!bonus);
  persistHistory({ ts, text, nums });
  renderRecent();
}

/* ====== 버튼 핸들링 ====== */
function updateButtons(){
  const hasRecent = (JSON.parse(localStorage.getItem(STORAGE_KEY)||'[]')).length > 0;
  copyBtn.disabled = !hasRecent;
  exportBtn.disabled = !hasRecent;
  clearBtn.disabled = !hasRecent;
}
copyBtn.addEventListener('click', async ()=>{
  try{
    const arr = JSON.parse(localStorage.getItem(STORAGE_KEY)||'[]');
    const text = arr.map(it=>`${it.ts}  ${it.text}`).join('\\n');
    await navigator.clipboard.writeText(text);
    copyBtn.textContent = '복사됨!';
    setTimeout(()=>copyBtn.textContent='텍스트 복사',900);
  }catch(e){ alert('복사 실패'); }
});
exportBtn.addEventListener('click', ()=>{
  const arr = JSON.parse(localStorage.getItem(STORAGE_KEY)||'[]');
  const blob = new Blob([JSON.stringify(arr, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = `pixel-lotto-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
});
clearBtn.addEventListener('click', ()=>{
  if(!confirm('저장된 기록을 모두 지우시겠어요?')) return;
  localStorage.removeItem(STORAGE_KEY);
  renderRecent(); updateButtons();
});

/* 즉시 생성(애니메이션 없이 화면에 배치) */
instantBtn.addEventListener('click', ()=>{
  const cnt = Math.max(1, Math.min(30, parseInt(countEl.value)||1));
  const includeBonus = bonusEl.checked;
  const allSets = [];
  for(let s=0;s<cnt;s++){
    const main = cryptoPick6();
    if(includeBonus){
      // pick extra bonus that's not in main
      const remaining = Array.from({length:45}, (_,i)=>i+1).filter(x=>!main.includes(x));
      const idx = Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0] / 0xFFFFFFFF * remaining.length);
      main.push(remaining.splice(idx,1)[0]);
    }
    allSets.push(main);
  }
  // show only first set in canvas for instant display
  spawnBallsForNumbers(allSets[0]);
  render();
  resultText.textContent = allSets.map((s,i)=>`세트 ${i+1}: ${formatResult(s, includeBonus)}`).join(' \\n ');
  recentLogPush(allSets[0], includeBonus? allSets[0][6] : null);
  updateButtons();
});

/* 생성 버튼: 애니메이션 포함 (세트별로 연속 실행) */
genBtn.addEventListener('click', async ()=>{
  if(world.state === 'running') return;
  const cnt = Math.max(1, Math.min(20, parseInt(countEl.value)||1));
  const includeBonus = bonusEl.checked;
  // build arrays: for each set, choose 6 + optional bonus
  const sets = [];
  for(let s=0;s<cnt;s++){
    const main = cryptoPick6();
    if(includeBonus){
      const remaining = Array.from({length:45}, (_,i)=>i+1).filter(x=>!main.includes(x));
      const idx = Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0] / 0xFFFFFFFF * remaining.length);
      main.push(remaining.splice(idx,1)[0]);
    }
    sets.push(main);
  }
  // run sequentially
  for(let i=0;i<sets.length;i++){
    await animateDrawSequence(sets[i], includeBonus);
    await delay(420);
  }
  updateButtons();
});

/* 초기 복원 */
(function init(){
  // set drum based on offscreen size
  world.drum.cx = off.width/2;
  world.drum.cy = off.height/2 - 6;
  world.drum.r = Math.min(off.width, off.height)*0.34;
  renderRecent();
  updateButtons();
  // keep a small physics/render loop if idle (so balls move)
  (async function backgroundLoop(){
    while(true){
      if(world.state === 'idle'){
        stepPhysics(1);
        render();
      }
      await delay(34);
    }
  })();
})();

</script>
</body>
</html>
