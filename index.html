<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>로또 머신 (2D) — Draw / Reset</title>
<style>
  :root{
    --bg:#06060a; --panel:#0b1224; --accent:#ffcc33; --muted:#9fb0ff; --btn:#ff4d4f;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#eaf0ff;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  #wrap{display:flex;gap:18px;align-items:flex-start;padding:18px}
  .left{width:820px;position:relative}
  canvas{display:block;width:820px;height:820px;border-radius:12px;background:linear-gradient(180deg,#081026,#041021)}
  .ui{width:260px;background:linear-gradient(180deg,#07102a,#071022);border-radius:12px;padding:16px;border:1px solid rgba(255,255,255,0.04)}
  h1{margin:0 0 8px;font-size:18px}
  .btn{display:inline-block;background:var(--btn);color:white;padding:12px 18px;border-radius:999px;border:0;font-weight:800;cursor:pointer;margin:8px 0;box-shadow:0 6px 18px rgba(0,0,0,0.45)}
  .btn.secondary{background:#2b3b6f}
  .label{color:var(--muted);font-size:13px;margin-top:8px;display:block}
  #recent{margin-top:10px;background:#061227;padding:8px;border-radius:8px;min-height:120px;max-height:260px;overflow:auto;font-family:monospace}
  #bigNumber{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);pointer-events:none;display:flex;align-items:center;justify-content:center;flex-direction:column}
  #bigNumber .circle{width:220px;height:220px;border-radius:50%;background:var(--accent);display:grid;place-items:center;font-weight:900;font-size:96px;color:#071027;box-shadow:0 14px 40px rgba(0,0,0,0.6)}
  #bigNumber .sub{margin-top:8px;color:rgba(255,255,255,0.85);font-weight:700}
  footer{color:var(--muted);font-size:12px;margin-top:12px}
  .small{font-size:13px;color:var(--muted)}
</style>
</head>
<body>
  <div id="wrap">
    <div class="left">
      <canvas id="c" width="820" height="820"></canvas>
      <div id="bigNumber" aria-live="polite" style="display:none">
        <div class="circle" id="bigNumCircle">00</div>
        <div class="sub" id="bigNumLabel">뽑힌 번호</div>
      </div>
    </div>

    <div class="ui" role="region" aria-label="컨트롤">
      <h1>로또 머신 (1~45)</h1>
      <div class="small">한쪽 출구에서 하나씩 뽑아 중앙에 크게 표시</div>

      <label class="label">조작</label>
      <button id="drawBtn" class="btn">Draw (한 개 뽑기)</button>
      <button id="resetBtn" class="btn secondary">Reset</button>

      <label class="label">옵션</label>
      <div style="display:flex;gap:8px;align-items:center;">
        <label class="small"><input type="checkbox" id="autoCenter" checked/> 중앙에 크게 표시</label>
      </div>

      <label class="label">최근 뽑힌 번호</label>
      <div id="recent">아직 뽑힌 번호가 없습니다.</div>

      <footer>Tip: GitHub Pages(HTTPS)에서 실행하면 소리가 더 확실히 재생됩니다.</footer>
    </div>
  </div>

<script>
/* ===== 유틸: crypto 정수 ===== */
function cryptoRandomInt(maxExclusive){
  // rejection sampling to reduce bias
  if (maxExclusive <= 0) return 0;
  const range = maxExclusive;
  const maxUint32 = 0xFFFFFFFF;
  const bucketSize = Math.floor((maxUint32 + 1) / range);
  const limit = bucketSize * range;
  const a = new Uint32Array(1);
  while(true){
    window.crypto.getRandomValues(a);
    const r = a[0];
    if(r < limit) return Math.floor(r / bucketSize);
  }
}

/* ===== 캔버스 & 렌더 준비 ===== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

/* ===== 머신 레이아웃(픽셀 단위) ===== */
const drum = {
  cx: Math.round(W*0.42),
  cy: Math.round(H*0.5),
  r: Math.round(Math.min(W,H)*0.37)
};
// 오른쪽 출구 시작 지점 (드럼 테두리 근처, 약 1시 방향)
const chute = {
  entryX: drum.cx + Math.cos(-Math.PI/6) * drum.r, 
  entryY: drum.cy + Math.sin(-Math.PI/6) * drum.r,
  // 통로 끝(중앙쪽)과 바깥쪽 길을 정의해서 애니메이션 경로로 사용
  midX: W*0.78, midY: H*0.55,
  endX: Math.round(W*0.62), endY: Math.round(H*0.3) // 중앙으로 들어오는 경로 끝(중앙보다 상단)
};

/* ===== 물리 파라미터 및 공 배열 ===== */
const BALL_COUNT = 45;
const balls = []; // {x,y,vx,vy,r,num,color,active}
const particles = []; // 간단 파티클
const removedNums = []; // 뽑힌 번호들 (순서대로)
let isAnimatingDraw = false;

/* 색상 팔레트 (로또 스타일 분류) */
function ballColor(n){
  if(n<=10) return '#ffd34d';
  if(n<=20) return '#6aa8ff';
  if(n<=30) return '#ff7a7a';
  if(n<=40) return '#b7c0d1';
  return '#62d2a2';
}

/* 초기 공 배치(무작위 위치, 속도) */
function initBalls(){
  balls.length = 0;
  removedNums.length = 0;
  for(let i=1;i<=BALL_COUNT;i++){
    // 무작위 위치: 드럼 내부 (충돌 없이 대략적으로)
    let x,y;
    let tries = 0;
    do{
      const ang = Math.random()*Math.PI*2;
      const rad = Math.random()*(drum.r - 18);
      x = drum.cx + Math.cos(ang)*rad;
      y = drum.cy + Math.sin(ang)*rad;
      tries++;
      // ensure not overlapping too much with existing placed balls
      let ok = true;
      for(const b of balls){
        const dx = b.x - x, dy = b.y - y;
        if(dx*dx + dy*dy < (b.r + 8)*(b.r + 8)){ ok = false; break;}
      }
      if(ok) break;
    }while(tries < 50);
    const speed = 0.6 + Math.random()*2.4;
    const dir = Math.random()*Math.PI*2;
    const r = 9 + Math.random()*1.6; // pixel radius
    balls.push({
      x,y,
      vx: Math.cos(dir)*speed,
      vy: Math.sin(dir)*speed,
      r: r,
      num: i,
      color: ballColor(i),
      active: true
    });
  }
}

/* 물리 스텝 (간단 탄성 충돌 및 원통 벽 반사) */
function stepPhysics(dt){
  const damping = 0.998;
  // integrate
  for(const b of balls){
    if(!b.active) continue;
    b.vy += 0.09 * dt; // 약한 중력
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.vx *= damping; b.vy *= damping;

    // wall collision: circular drum
    const dx = b.x - drum.cx, dy = b.y - drum.cy;
    const dist = Math.hypot(dx, dy);
    const limit = drum.r - b.r - 1;
    if(dist > limit){
      // normal
      const nx = dx / dist, ny = dy / dist;
      // push inside
      const overlap = dist - limit;
      b.x -= nx * overlap; b.y -= ny * overlap;
      // reflect velocity
      const vdotn = b.vx*nx + b.vy*ny;
      b.vx -= 1.98 * vdotn * nx;
      b.vy -= 1.98 * vdotn * ny;
      // small particle & sound
      spawnParticles(b.x, b.y, 6);
      playPopSmall(0.06 + Math.min(0.35, Math.abs(vdotn)*0.05));
    }
  }
  // pairwise collisions (O(n^2) but n=<=45)
  for(let i=0;i<balls.length;i++){
    const a = balls[i];
    if(!a.active) continue;
    for(let j=i+1;j<balls.length;j++){
      const b = balls[j];
      if(!b.active) continue;
      const dx = b.x - a.x, dy = b.y - a.y;
      const d2 = dx*dx + dy*dy;
      const minDist = a.r + b.r;
      if(d2 < minDist*minDist && d2 > 0.0001){
        const d = Math.sqrt(d2);
        const nx = dx / d, ny = dy / d;
        const overlap = 0.5 * (minDist - d + 0.01);
        a.x -= nx * overlap; a.y -= ny * overlap;
        b.x += nx * overlap; b.y += ny * overlap;
        // relative velocity along normal
        const rvx = b.vx - a.vx, rvy = b.vy - a.vy;
        const sepVel = rvx*nx + rvy*ny;
        if(sepVel < 0){
          const impulse = - (1.9 * sepVel) / 2;
          a.vx -= impulse * nx; a.vy -= impulse * ny;
          b.vx += impulse * nx; b.vy += impulse * ny;
          spawnParticles((a.x+b.x)/2, (a.y+b.y)/2, 3);
          playPopSmall(0.04);
        }
      }
    }
  }

  // particles update
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx * dt * 0.9;
    p.y += p.vy * dt * 0.9;
    p.vy += 0.08 * dt;
    p.life -= dt*16;
    if(p.life <= 0) particles.splice(i,1);
  }
}

/* 그리기 */
function draw(){
  // clear
  ctx.clearRect(0,0,W,H);
  // background
  const grad = ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0,'#081028'); grad.addColorStop(1,'#041024');
  ctx.fillStyle = grad; ctx.fillRect(0,0,W,H);

  // drum outline
  ctx.beginPath();
  ctx.lineWidth = 6;
  ctx.strokeStyle = '#ffffff';
  ctx.arc(drum.cx, drum.cy, drum.r, 0, Math.PI*2);
  ctx.stroke();

  // draw chute path (simple curve)
  ctx.beginPath();
  ctx.lineWidth = 6; ctx.strokeStyle = '#ffffff';
  const startAngle = -Math.PI/6;
  const ex = chute.entryX, ey = chute.entryY;
  const ctrl1x = drum.cx + (drum.r + 40);
  const ctrl1y = drum.cy + 20;
  ctx.moveTo(ex, ey);
  // curve outward
  ctx.quadraticCurveTo(ctrl1x, ctrl1y, chute.midX, chute.midY);
  // curve to center area
  ctx.quadraticCurveTo((chute.midX+chute.endX)/2, (chute.midY+chute.endY)/2, chute.endX, chute.endY);
  ctx.stroke();

  // draw particles (tiny)
  for(const p of particles){
    ctx.fillStyle = `rgba(${p.color[0]},${p.color[1]},${p.color[2]},${Math.max(0, p.life/100)})`;
    ctx.fillRect(p.x-1, p.y-1, 2, 2);
  }

  // draw balls (z-order by y)
  const sorted = balls.slice().sort((a,b)=>a.y - b.y);
  for(const b of sorted){
    if(!b.active) continue;
    // draw simple circle with inner shade
    const grd = ctx.createRadialGradient(b.x - b.r*0.2, b.y - b.r*0.4, b.r*0.2, b.x, b.y, b.r);
    grd.addColorStop(0, '#fff5'); grd.addColorStop(0.15, '#ffffff0a');
    grd.addColorStop(0.85, b.color); grd.addColorStop(1, shadeColor(b.color, -18));
    ctx.fillStyle = grd;
    ctx.beginPath(); ctx.arc(b.x, b.y, b.r,0,Math.PI*2); ctx.fill();
    // outline
    ctx.lineWidth = 1.2; ctx.strokeStyle = '#061027';
    ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.stroke();
    // number (dark small)
    ctx.fillStyle = '#071027';
    ctx.font = `${Math.max(8, Math.round(b.r * 1.1))}px monospace`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(String(b.num).padStart(2,'0'), b.x, b.y+0.5);
  }

  // draw already removed small tokens near chute path (optional)
  // done elsewhere (recent list)

  // overlay subtle center vignette
  const vign = ctx.createRadialGradient(W/2, H/2, 20, W/2, H/2, W*0.8);
  vign.addColorStop(0, 'rgba(0,0,0,0)');
  vign.addColorStop(1, 'rgba(0,0,0,0.25)');
  ctx.fillStyle = vign; ctx.fillRect(0,0,W,H);
}

/* 색상 보정 헬퍼 */
function shadeColor(hex, percent) {
  // hex like '#rrggbb' to shaded hex
  const c = hex.replace('#','');
  const num = parseInt(c,16);
  const r = Math.max(0, Math.min(255, Math.floor((num >> 16) + percent)));
  const g = Math.max(0, Math.min(255, Math.floor(((num >> 8) & 0xFF) + percent)));
  const b = Math.max(0, Math.min(255, Math.floor((num & 0xFF) + percent)));
  return `rgb(${r},${g},${b})`;
}

/* 파티클 생성 */
function spawnParticles(x,y,count=8){
  for(let i=0;i<count;i++){
    particles.push({
      x:x + (Math.random()-0.5)*6,
      y:y + (Math.random()-0.5)*6,
      vx:(Math.random()-0.5)*1.6,
      vy:(Math.random()-1.0)*1.6,
      life: 60 + Math.random()*80,
      color: [200,220,255]
    });
  }
}

/* 소리: 간단 팝 (WebAudio) */
let audioCtx = null;
function ensureAudio(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if(audioCtx.state === 'suspended') audioCtx.resume();
}
function playPopSmall(vol=0.08){
  try{
    ensureAudio();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'triangle';
    o.frequency.value = 700 + Math.random()*300;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    o.start(now);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.05);
    o.stop(now + 0.06);
  }catch(e){}
}
function playBigPop(){
  try{
    ensureAudio();
    const o1 = audioCtx.createOscillator();
    const g1 = audioCtx.createGain();
    o1.type = 'sine'; o1.frequency.value = 520;
    g1.gain.value = 0.28;
    o1.connect(g1); g1.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    o1.start(now); g1.gain.exponentialRampToValueAtTime(0.0001, now + 0.22); o1.stop(now + 0.24);
  }catch(e){}
}

/* 드로우 애니메이션: 선택된 하나를 출구로 이동시키고 통로 따라 중앙으로 */
function animateDrawOne(selectedNum){
  return new Promise(async (resolve)=>{
    // find ball object
    const b = balls.find(x => x.num === selectedNum && x.active);
    if(!b){ resolve(); return; }
    // mark inactive for physics so it won't be collided with
    b.active = false;

    // 1) move to drum edge toward entry point (simulate being pulled to entry)
    const entryX = chute.entryX, entryY = chute.entryY;
    const steps1 = 18;
    for(let i=0;i<steps1;i++){
      b.x += (entryX - b.x) * 0.18;
      b.y += (entryY - b.y) * 0.18;
      spawnParticles(b.x, b.y, 2);
      stepPhysics(1);
      draw();
      await tick();
    }

    // 2) follow path: entry -> mid -> end -> center display point
    const path = [
      {x: entryX, y: entryY},
      {x: chute.midX, y: chute.midY},
      {x: chute.endX, y: chute.endY},
      {x: W*0.5, y: H*0.5} // final center
    ];
    // move along segments with easing
    for(let seg=0; seg<path.length; seg++){
      const to = path[seg];
      const segFrames = seg===path.length-1 ? 40 : 26; // final segment slower
      for(let f=0; f<segFrames; f++){
        const t = easeOutCubic(f / segFrames);
        b.x = lerp(b.x, to.x, t*0.9 + 0.1);
        b.y = lerp(b.y, to.y, t*0.9 + 0.1);
        spawnParticles(b.x, b.y, 1);
        if(seg===path.length-1 && f%6===0) playPopSmall(0.06);
        draw();
        await tick();
      }
    }

    // final pop: show big number and small party
    playBigPop();
    for(let i=0;i<12;i++) spawnParticles(b.x + (Math.random()-0.5)*30, b.y + (Math.random()-0.5)*30, 6);
    draw();
    // mark removed: turn b.active false, store removed num
    b.active = false;
    removedNums.push(b.num);
    updateRecent();
    // display central big number
    showBigNumber(b.num);
    await delay(600);
    hideBigNumber();
    resolve();
  });
}

/* helpers */
function lerp(a,b,t){ return a + (b-a)*t; }
function easeOutCubic(t){ return 1 - Math.pow(1-t,3); }
function tick(){ return new Promise(r => requestAnimationFrame(r)); }
function delay(ms){ return new Promise(r => setTimeout(r, ms)); }

/* recent UI */
function updateRecent(){
  const el = document.getElementById('recent');
  if(removedNums.length === 0) el.textContent = '아직 뽑힌 번호가 없습니다.';
  else el.textContent = removedNums.slice().reverse().map((n,i)=>`${removedNums.length-i}. ${String(n).padStart(2,'0')}`).join('\n');
}

/* big number UI */
function showBigNumber(n){
  const wrap = document.getElementById('bigNumber');
  const circle = document.getElementById('bigNumCircle');
  circle.textContent = String(n).padStart(2,'0');
  wrap.style.display = 'flex';
}
function hideBigNumber(){
  const wrap = document.getElementById('bigNumber');
  wrap.style.display = 'none';
}

/* draw button handler: choose random remaining ball, animate it */
async function handleDraw(){
  if(isAnimatingDraw) return;
  // find remaining numbers
  const remain = balls.filter(b => b.active).map(b=>b.num);
  if(remain.length === 0){
    alert('모든 공이 뽑혔습니다. Reset 해주세요.');
    return;
  }
  isAnimatingDraw = true;
  // choose random index via crypto
  const idx = cryptoRandomInt(remain.length);
  const chosen = remain[idx];
  // animate
  await animateDrawOne(chosen);
  isAnimatingDraw = false;
}

/* reset */
function handleReset(){
  initBalls();
  updateRecent();
  hideBigNumber();
}

/* 모듈 초기화, 루프 */
function init(){
  initBalls();
  updateRecent();
  hideBigNumber();
  draw();
  loop();
}

/* 메인 루프 */
let last = performance.now();
function loop(now){
  requestAnimationFrame(loop);
  const t = performance.now();
  const dt = Math.min(3, (t - last) / 16.666); // frame-normalized
  last = t;
  if(!isAnimatingDraw){
    // run physics only if not actively animating draw (to keep stable)
    stepPhysics(dt);
  }
  draw();
}

/* UI 바인딩 */
document.getElementById('drawBtn').addEventListener('click', async ()=>{
  // ensure audio resume on user gesture:
  try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }catch(e){}
  await handleDraw();
});
document.getElementById('resetBtn').addEventListener('click', handleReset);

/* boot */
init();

</script>
</body>
</html>
