<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3D 로또 </title>
<style>
  html,body{height:100%;margin:0;background:#0b1020;color:#e9edff;font-family:system-ui,Segoe UI,Roboto,Arial}
  #ui{position:fixed;left:50%;top:14px;transform:translateX(-50%);z-index:20;text-align:center}
  button{background:#6aa8ff;border:0;padding:10px 14px;border-radius:10px;font-weight:700;cursor:pointer}
  #numbers{margin-top:8px;color:#dfe8ff}
  #err{position:fixed;left:12px;bottom:12px;right:12px;padding:10px;border-radius:8px;background:#2b1b1b;color:#ffd6d6;display:none;white-space:pre-wrap}
  canvas{display:block}
</style>
</head>
<body>
  <div id="ui">
    <button id="genBtn">🎲 로또 번호 뽑기 (3D)</button>
    <div id="numbers">번호: —</div>
  </div>
  <div id="err"></div>
  <canvas id="c"></canvas>

  <!-- CDN UMD 번들: three / cannon-es / howler -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/howler@2.2.4/dist/howler.min.js"></script>

  <script>
  (function(){
    const showError = (e) => {
      console.error(e);
      const el = document.getElementById('err');
      el.style.display = 'block';
      el.textContent = typeof e === 'string' ? e : (e && e.message ? e.message : JSON.stringify(e));
    };

    try {
      // 캔버스와 렌더러
      const canvas = document.getElementById('c');
      const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(innerWidth, innerHeight, false);
      renderer.shadowMap.enabled = true;

      // 씬/카메라
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b1020);
      const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 200);
      camera.position.set(0, 8, 18);

      // 조명
      const amb = new THREE.AmbientLight(0xffffff, 0.45); scene.add(amb);
      const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(8, 18, 12); dir.castShadow = true; scene.add(dir);

      // 바닥
      const ground = new THREE.Mesh(new THREE.PlaneGeometry(120,120), new THREE.MeshStandardMaterial({color:0x071028}));
      ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

      // 물리(CANNON)
      if(!window.CANNON) throw new Error('CANNON 라이브러리 로드 실패');
      const world = new CANNON.World({gravity: new CANNON.Vec3(0, -9.82, 0)});
      world.broadphase = new CANNON.SAPBroadphase(world);
      world.allowSleep = true;
      const mat = new CANNON.Material('ballmat');
      const contact = new CANNON.ContactMaterial(mat, mat, { friction: 0.02, restitution: 0.8 });
      world.addContactMaterial(contact);

      // 바닥 물리
      const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: mat });
      groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
      world.addBody(groundBody);

      // 오디오(Howler)
      const bounce = new Howl({ src: ['https://actions.google.com/sounds/v1/impacts/metal_thud.ogg'], volume: 0.25 });
      // 브라우저 음성 재생 정책 대응: 첫 사용자 입력 시 resume
      let audioReady = false;
      window.addEventListener('pointerdown', ()=>{ if(!audioReady){ Howler.ctx && Howler.ctx.resume && Howler.ctx.resume(); audioReady = true; } }, { once:true });

      // 공 생성 함수
      const balls = []; // {mesh, body, number}
      const sphereGeo = new THREE.SphereGeometry(0.55, 24, 24);
      function colorFor(n){
        if(n<=10) return 0xFFD34D;
        if(n<=20) return 0x6AA8FF;
        if(n<=30) return 0xFF7A7A;
        if(n<=40) return 0xB7C0D1;
        return 0x62D2A2;
      }
      function makeNumberTexture(n){
        const s = 256; const cvs = document.createElement('canvas'); cvs.width=cvs.height=s;
        const ctx = cvs.getContext('2d'); ctx.clearRect(0,0,s,s);
        ctx.fillStyle = 'rgba(0,0,0,0)';
        ctx.fillRect(0,0,s,s);
        ctx.fillStyle = 'white'; ctx.font = 'bold 140px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.shadowColor='rgba(0,0,0,0.5)'; ctx.shadowBlur=8; ctx.fillText(String(n).padStart(2,'0'), s/2, s/2);
        return new THREE.CanvasTexture(cvs);
      }

      function clearBalls(){
        balls.forEach(b=>{
          scene.remove(b.mesh);
          world.removeBody(b.body);
        });
        balls.length = 0;
      }

      function spawnBallsFromNumbers(numbers){
        clearBalls();
        numbers.forEach((num, idx)=>{
          const matThree = new THREE.MeshStandardMaterial({ color: colorFor(num), metalness:0.25, roughness:0.4 });
          const mesh = new THREE.Mesh(sphereGeo, matThree);
          mesh.castShadow = true; mesh.receiveShadow = true;
          const sprMat = new THREE.SpriteMaterial({ map: makeNumberTexture(num), depthTest: false });
          const spr = new THREE.Sprite(sprMat); spr.scale.set(0.9,0.9,0.9); spr.position.set(0,0,0.56);
          mesh.add(spr);

          // start pos: 위에서 흩뿌림
          const x = (Math.random()-0.5)*6;
          const y = 8 + Math.random()*2;
          const z = (Math.random()-0.5)*6;
          mesh.position.set(x,y,z);
          scene.add(mesh);

          const body = new CANNON.Body({ mass: 0.28, shape: new CANNON.Sphere(0.55), position: new CANNON.Vec3(x,y,z), material: mat });
          body.linearDamping = 0.01; body.angularDamping = 0.01;
          // 초기 속도 약간
          body.velocity.set((Math.random()-0.5)*6, (Math.random()-0.2)*1, (Math.random()-0.5)*6);
          body.addEventListener('collide', (ev)=>{
            // 충돌 강도에 따라 소리
            const impact = ev.contact.getImpactVelocityAlongNormal();
            if(impact > 1.0) bounce.play();
          });
          world.addBody(body);
          balls.push({mesh, body, number: num});
        });
      }

      // 로또 생성 (crypto 안전)
      function secureRandomInt(maxExclusive){
        // returns integer 0..maxExclusive-1
        const arr = new Uint32Array(1);
        window.crypto.getRandomValues(arr);
        return Math.floor(arr[0] / 0xFFFFFFFF * maxExclusive);
      }
      function generate6(){
        const pool = Array.from({length:45}, (_,i)=>i+1);
        // Fisher-Yates
        for(let i=pool.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [pool[i],pool[j]]=[pool[j],pool[i]]; }
        const res = pool.slice(0,6).sort((a,b)=>a-b);
        return res;
      }
      // 위는 Math.random shuffle — acceptable for UI. If you want crypto shuffle, use getRandomValues per swap.

      // UI 연결
      const genBtn = document.getElementById('genBtn');
      const numbersEl = document.getElementById('numbers');
      genBtn.addEventListener('click', ()=>{
        try {
          // generate 6 secure numbers
          const nums = (function cryptoShufflePick6(){
            // crypto-based selection without duplicate
            const pool = Array.from({length:45}, (_,i)=>i+1);
            // use window.crypto to select 6 items by removing chosen ones
            const chosen = [];
            for(let k=0;k<6;k++){
              const idx = Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0] / 0xFFFFFFFF * (pool.length));
              chosen.push(pool.splice(idx,1)[0]);
            }
            return chosen.sort((a,b)=>a-b);
          })();
          numbersEl.textContent = '번호: ' + nums.join(', ');
          spawnBallsFromNumbers(nums);
        } catch(e){ showError(e); }
      });

      // 애니메이션 루프
      let lastTime;
      function animate(t){
        requestAnimationFrame(animate);
        if(!lastTime) lastTime = t;
        const dt = Math.min(0.05, (t - lastTime) / 1000);
        lastTime = t;
        // 물리 스텝 (fixstep)
        world.step(1/60, dt, 3);
        // 동기화
        balls.forEach(b=>{
          b.mesh.position.copy(b.body.position);
          b.mesh.quaternion.copy(b.body.quaternion);
          // 숫자 스프라이트는 항상 카메라를 보게
          if(b.mesh.children.length>0 && b.mesh.children[0].isSprite) b.mesh.children[0].lookAt(camera.position);
        });
        renderer.render(scene, camera);
      }
      requestAnimationFrame(animate);

      // 리사이즈
      window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight, false); });
      renderer.setSize(innerWidth, innerHeight, false);

      // 안내: GitHub Pages로 열어야 함을 텍스트로 표시 (file:// 차단 대응)
      if(location.protocol === 'file:'){
        showError('경고: 현재 file:// 로 열림 — 모듈/사운드 등 브라우저 정책으로 정상 동작하지 않을 수 있습니다.\nGitHub Pages(https) 또는 로컬 HTTP 서버에서 열어보세요.');
      }
    } catch(err){
      showError(err);
    }
  })();
  </script>
</body>
</html>
