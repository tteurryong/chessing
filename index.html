<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>3D 로또 번호 뽑기</title>
<style>
html,body {margin:0; padding:0; background:#111; overflow:hidden; height:100%;}
#ui {
    position:absolute; top:20px; left:50%; transform:translateX(-50%);
    z-index:10; text-align:center; color:white; font-family:sans-serif;
}
button {
    background:#ff4444; color:white; border:none; padding:10px 20px;
    margin:5px; font-size:16px; border-radius:5px; cursor:pointer;
}
#numbers { margin-top:10px; font-size:18px; }
</style>
</head>
<body>
<div id="ui">
    <button id="generate">🎲 로또 번호 뽑기</button>
    <div id="numbers"></div>
</div>
<canvas id="scene"></canvas>

<!-- CDN 라이브러리 -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
<script src="https://cdn.jsdelivr.net/npm/howler@2.2.4/dist/howler.min.js"></script>

<script>
const canvas = document.getElementById('scene');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);

// 장면 & 카메라
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0, 8, 14);

// 조명
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5, 10, 7);
scene.add(light);
scene.add(new THREE.AmbientLight(0xffffff, 0.4));

// 물리 세계
const world = new CANNON.World({gravity:new CANNON.Vec3(0, -9.82, 0)});
world.broadphase = new CANNON.NaiveBroadphase();
const groundMat = new CANNON.Material();
const groundBody = new CANNON.Body({
    mass:0,
    shape:new CANNON.Plane(),
    material:groundMat
});
groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
world.addBody(groundBody);

// 바닥 메시
const groundGeo = new THREE.PlaneGeometry(50, 50);
const groundMatMesh = new THREE.MeshStandardMaterial({color:0x222222});
const groundMesh = new THREE.Mesh(groundGeo, groundMatMesh);
groundMesh.rotation.x = -Math.PI/2;
scene.add(groundMesh);

// 사운드
const bounceSound = new Howl({
    src:['https://cdn.pixabay.com/audio/2022/03/15/audio_5f47670274.mp3'],
    volume:0.3
});

// 공 배열
let balls = [];
function createBall(number) {
    const radius = 0.5;
    const sphereGeo = new THREE.SphereGeometry(radius, 32, 32);
    const sphereMat = new THREE.MeshStandardMaterial({color:getBallColor(number)});
    const sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);

    const sphereShape = new CANNON.Sphere(radius);
    const sphereBody = new CANNON.Body({
        mass:1,
        shape:sphereShape,
        position:new CANNON.Vec3((Math.random()-0.5)*5, 5+Math.random()*2, (Math.random()-0.5)*5)
    });
    sphereBody.addEventListener('collide', () => {
        bounceSound.play();
    });

    scene.add(sphereMesh);
    world.addBody(sphereBody);
    balls.push({mesh:sphereMesh, body:sphereBody, number});
}

// 공 색상
function getBallColor(n) {
    if (n<=10) return 0xFFD700; // 노랑
    if (n<=20) return 0x00BFFF; // 파랑
    if (n<=30) return 0xFF4500; // 주황
    if (n<=40) return 0x32CD32; // 초록
    return 0xFF1493; // 분홍
}

// 로또 번호 생성
function generateNumbers() {
    const nums = new Set();
    while(nums.size<6) {
        nums.add(Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0] / 0xffffffff * 45) + 1);
    }
    return Array.from(nums).sort((a,b)=>a-b);
}

// UI 이벤트
document.getElementById('generate').addEventListener('click', ()=>{
    // 기존 공 제거
    balls.forEach(b=>{
        scene.remove(b.mesh);
        world.removeBody(b.body);
    });
    balls = [];

    const numbers = generateNumbers();
    document.getElementById('numbers').innerText = '번호: ' + numbers.join(', ');

    numbers.forEach(n=> createBall(n));
});

// 애니메이션 루프
function animate() {
    requestAnimationFrame(animate);
    world.step(1/60);
    balls.forEach(b=>{
        b.mesh.position.copy(b.body.position);
        b.mesh.quaternion.copy(b.body.quaternion);
    });
    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
