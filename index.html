<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>3D ë¡œë˜ ë²ˆí˜¸ ë½‘ê¸°</title>
<style>
html,body {margin:0; padding:0; background:#111; overflow:hidden; height:100%;}
#ui {
    position:absolute; top:20px; left:50%; transform:translateX(-50%);
    z-index:10; text-align:center; color:white; font-family:sans-serif;
}
button {
    background:#ff4444; color:white; border:none; padding:10px 20px;
    margin:5px; font-size:16px; border-radius:5px; cursor:pointer;
}
#numbers { margin-top:10px; font-size:18px; }
</style>
</head>
<body>
<div id="ui">
    <button id="generate">ğŸ² ë¡œë˜ ë²ˆí˜¸ ë½‘ê¸°</button>
    <div id="numbers"></div>
</div>
<canvas id="scene"></canvas>

<!-- CDN ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
<script src="https://cdn.jsdelivr.net/npm/howler@2.2.4/dist/howler.min.js"></script>

<script>
const canvas = document.getElementById('scene');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);

// ì¥ë©´ & ì¹´ë©”ë¼
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0, 8, 14);

// ì¡°ëª…
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5, 10, 7);
scene.add(light);
scene.add(new THREE.AmbientLight(0xffffff, 0.4));

// ë¬¼ë¦¬ ì„¸ê³„
const world = new CANNON.World({gravity:new CANNON.Vec3(0, -9.82, 0)});
world.broadphase = new CANNON.NaiveBroadphase();
const groundMat = new CANNON.Material();
const groundBody = new CANNON.Body({
    mass:0,
    shape:new CANNON.Plane(),
    material:groundMat
});
groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
world.addBody(groundBody);

// ë°”ë‹¥ ë©”ì‹œ
const groundGeo = new THREE.PlaneGeometry(50, 50);
const groundMatMesh = new THREE.MeshStandardMaterial({color:0x222222});
const groundMesh = new THREE.Mesh(groundGeo, groundMatMesh);
groundMesh.rotation.x = -Math.PI/2;
scene.add(groundMesh);

// ì‚¬ìš´ë“œ
const bounceSound = new Howl({
    src:['https://cdn.pixabay.com/audio/2022/03/15/audio_5f47670274.mp3'],
    volume:0.3
});

// ê³µ ë°°ì—´
let balls = [];
function createBall(number) {
    const radius = 0.5;
    const sphereGeo = new THREE.SphereGeometry(radius, 32, 32);
    const sphereMat = new THREE.MeshStandardMaterial({color:getBallColor(number)});
    const sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);

    const sphereShape = new CANNON.Sphere(radius);
    const sphereBody = new CANNON.Body({
        mass:1,
        shape:sphereShape,
        position:new CANNON.Vec3((Math.random()-0.5)*5, 5+Math.random()*2, (Math.random()-0.5)*5)
    });
    sphereBody.addEventListener('collide', () => {
        bounceSound.play();
    });

    scene.add(sphereMesh);
    world.addBody(sphereBody);
    balls.push({mesh:sphereMesh, body:sphereBody, number});
}

// ê³µ ìƒ‰ìƒ
function getBallColor(n) {
    if (n<=10) return 0xFFD700; // ë…¸ë‘
    if (n<=20) return 0x00BFFF; // íŒŒë‘
    if (n<=30) return 0xFF4500; // ì£¼í™©
    if (n<=40) return 0x32CD32; // ì´ˆë¡
    return 0xFF1493; // ë¶„í™
}

// ë¡œë˜ ë²ˆí˜¸ ìƒì„±
function generateNumbers() {
    const nums = new Set();
    while(nums.size<6) {
        nums.add(Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0] / 0xffffffff * 45) + 1);
    }
    return Array.from(nums).sort((a,b)=>a-b);
}

// UI ì´ë²¤íŠ¸
document.getElementById('generate').addEventListener('click', ()=>{
    // ê¸°ì¡´ ê³µ ì œê±°
    balls.forEach(b=>{
        scene.remove(b.mesh);
        world.removeBody(b.body);
    });
    balls = [];

    const numbers = generateNumbers();
    document.getElementById('numbers').innerText = 'ë²ˆí˜¸: ' + numbers.join(', ');

    numbers.forEach(n=> createBall(n));
});

// ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
function animate() {
    requestAnimationFrame(animate);
    world.step(1/60);
    balls.forEach(b=>{
        b.mesh.position.copy(b.body.position);
        b.mesh.quaternion.copy(b.body.quaternion);
    });
    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
