<!doctype html>

<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>체스 & 알까기 — 통합 인덱스</title>
  <style>
    :root{--size:64px;--gap:6px;--bg:#071025}
    *{box-sizing:border-box}
    body{font-family:Inter, system-ui, -apple-system, "Noto Sans KR", "Segoe UI", Roboto, sans-serif;margin:0;background:linear-gradient(180deg,#041226,var(--bg));color:#e6eef8;min-height:100vh;display:flex;flex-direction:column;align-items:center;padding:18px}
    header{display:flex;gap:12px;align-items:center;width:100%;max-width:1100px}
    h1{font-size:1.05rem;margin:0}
    .app{display:flex;gap:18px;width:100%;max-width:1100px;margin-top:14px}
    .board-wrap{background:linear-gradient(180deg,#0b1220,#071025);padding:12px;border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,.7)}.board{display:grid;grid-template-columns:repeat(8,var(--size));grid-template-rows:repeat(8,var(--size));gap:6px;padding:8px;border-radius:10px}
.cell{width:var(--size);height:var(--size);border-radius:8px;display:flex;align-items:center;justify-content:center;position:relative;user-select:none}
.cell.light{background:#cfe7f7}
.cell.dark{background:#2b5670}
.cell.highlight{outline:3px solid rgba(255,255,255,.12)}
.piece{width:52%;height:52%;display:flex;align-items:center;justify-content:center;border-radius:6px;font-weight:700;transition:transform .12s ease,box-shadow .12s ease}
.p1{background:linear-gradient(180deg,#ffd36b,#ffb84d);color:#391f06;box-shadow:0 6px 14px rgba(255,176,61,.18)}
.p2{background:linear-gradient(180deg,#7fd3ff,#4db3ff);color:#022033;box-shadow:0 6px 14px rgba(77,179,255,.16)}
.controls{display:flex;flex-direction:column;gap:10px;padding:8px;min-width:260px}
.panel{background:rgba(255,255,255,.03);padding:10px;border-radius:10px}
label{display:flex;gap:8px;align-items:center}
select,input[type=range]{width:100%}
.row{display:flex;gap:8px}
button{background:#092738;border:1px solid rgba(255,255,255,.04);color:#dbeeff;padding:8px 10px;border-radius:8px;cursor:pointer}
.log{max-height:220px;overflow:auto;font-size:13px;padding:8px;border-radius:8px;background:rgba(0,0,0,.12)}

/* animations */
.fade{transition:transform .18s ease,opacity .18s ease}
.jump-anim{animation:jump .28s ease}
@keyframes jump{0%{transform:translateY(0)}50%{transform:translateY(-12px)}100%{transform:translateY(0)}}

@media(max-width:820px){:root{--size:44px} .app{flex-direction:column;align-items:center} .controls{width:100%}}

  </style>
</head>
<body>
  <header>
    <h1>체스 & 알까기 — 통합 데모</h1>
    <div style="margin-left:auto;font-size:13px;opacity:.9">로컬 테스트용 — GitHub 업로드 가능</div>
  </header>  <div class="app">
    <div class="board-wrap">
      <div id="board" class="board" role="grid" aria-label="게임 보드"></div>
    </div><div class="controls">
  <div class="panel">
    <div class="row">
      <label>모드
        <select id="mode">
          <option value="alkk">알까기 (체커식 점프)</option>
          <option value="chess">체스 (기본 이동 규칙)</option>
        </select>
      </label>
      <label>대상
        <select id="opponent">
          <option value="local">로컬 2인</option>
          <option value="easy">컴퓨터 (쉬움)</option>
          <option value="hard">컴퓨터 (어려움)</option>
        </select>
      </label>
    </div>
    <div class="row" style="margin-top:8px">
      <button id="reset">초기화</button>
      <button id="undo">되돌리기</button>
      <button id="hint">힌트 (컴퓨터추천)</button>
    </div>
  </div>

  <div class="panel">
    <div>턴: <strong id="turn">플레이어 1</strong></div>
    <div style="margin-top:6px" class="log" id="log"></div>
  </div>

  <div class="panel">
    <div style="font-size:13px;opacity:.9">조작: 말 클릭 → 이동할 칸 클릭 · 모바일(터치) 지원</div>
    <div style="margin-top:8px;font-size:12px;color:#bcd">애니메이션, 반응형 UI, 간단 AI 포함</div>
  </div>
</div>

  </div><script>
// 통합 게임 엔진: mode에 따라 동작 분기
const ROWS=8,COLS=8;
const boardEl=document.getElementById('board');
const turnEl=document.getElementById('turn');
const modeSelect=document.getElementById('mode');
const opponentSelect=document.getElementById('opponent');
const resetBtn=document.getElementById('reset');
const undoBtn=document.getElementById('undo');
const hintBtn=document.getElementById('hint');
const logEl=document.getElementById('log');

let state={grid:[],turn:1,selected:null,history:[],mode:'alkk'};

// piece encoding for chess: {type:'P','R','N','B','Q','K', owner:1/2}
// for alkka: piece is owner number

function boot(){ state.mode = modeSelect.value; initGrid(); state.turn=1; state.selected=null; state.history=[]; render(); log('게임 시작 — 모드: '+(state.mode==='alkk'? '알까기':'체스')); }

function initGrid(){
  if(modeSelect.value==='alkk'){
    const g=Array.from({length:ROWS}, ()=>Array(COLS).fill(0));
    for(let r=0;r<2;r++) for(let c=0;c<COLS;c++) g[r][c]=2;
    for(let r=ROWS-2;r<ROWS;r++) for(let c=0;c<COLS;c++) g[r][c]=1;
    state.grid=g; return;
  }
  // chess initial
  const empty=()=>Array.from({length:COLS},()=>null);
  const g=[]; g.push([
    {t:'R',o:2},{t:'N',o:2},{t:'B',o:2},{t:'Q',o:2},{t:'K',o:2},{t:'B',o:2},{t:'N',o:2},{t:'R',o:2}
  ]);
  g.push(Array.from({length:COLS},()=>({t:'P',o:2})));
  for(let i=0;i<4;i++) g.push(empty());
  g.push(Array.from({length:COLS},()=>({t:'P',o:1})));
  g.push([
    {t:'R',o:1},{t:'N',o:1},{t:'B',o:1},{t:'Q',o:1},{t:'K',o:1},{t:'B',o:1},{t:'N',o:1},{t:'R',o:1}
  ]);
  state.grid=g;
}

function render(){ boardEl.innerHTML='';
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell=document.createElement('div'); cell.className='cell '+(((r+c)%2)?'dark':'light'); cell.dataset.r=r; cell.dataset.c=c;
      const p = state.grid[r][c];
      if(p){
        const piece=document.createElement('div'); piece.className='piece fade';
        if(state.mode==='alkk'){
          piece.classList.add('p'+p);
          piece.textContent = p===1? '●':'○';
        } else {
          piece.classList.add(p.o===1? 'p1':'p2');
          piece.textContent = pSymbols(p.t, p.o);
        }
        cell.appendChild(piece);
      }
      cell.addEventListener('click', onCellClick);
      boardEl.appendChild(cell);
    }
  }
  updateUI();
}

function pSymbols(t,o){ // 한글/심볼 (간단)
  const map={P:'♙',R:'♖',N:'♘',B:'♗',Q:'♕',K:'♔'};
  const s=map[t]||t; return o===1? s : flipSymbol(s);
}
function flipSymbol(s){ return s.replace('♙','♟').replace('♖','♜').replace('♘','♞').replace('♗','♝').replace('♕','♛').replace('♔','♚'); }

function updateUI(){
  turnEl.textContent = state.turn===1? '플레이어 1' : '플레이어 2 / 컴퓨터';
  document.querySelectorAll('.cell').forEach(el=>el.classList.remove('highlight'));
  if(state.selected){ const [sr,sc]=state.selected; const selEl=queryCell(sr,sc); if(selEl) selEl.classList.add('highlight');
    const moves = legalMoves(sr,sc);
    moves.forEach(m=>{ const el=queryCell(m[0],m[1]); if(el) el.classList.add('highlight'); });
  }
}

function queryCell(r,c){ return boardEl.querySelector(`.cell[data-r='${r}'][data-c='${c}']`); }

function onCellClick(e){ const r=+this.dataset.r, c=+this.dataset.c;
  const cellVal = state.grid[r][c];
  if(state.selected){ const [sr,sc]=state.selected;
    if(sr===r && sc===c){ state.selected=null; updateUI(); return; }
    // if own piece, change selection
    if(state.mode==='alkk' ? cellVal===state.turn : (cellVal && cellVal.o===state.turn)){ state.selected=[r,c]; updateUI(); return; }
    const moves=legalMoves(sr,sc).map(JSON.stringify);
    const target=JSON.stringify([r,c]);
    if(moves.includes(target)){
      pushHistory();
      performMove(sr,sc,r,c);
      animateMove(sr,sc,r,c);
      // after move, handle turn
      state.selected=null; state.turn=3-state.turn; render(); checkGameOver();
      // if opponent is computer, run it
      if(opponentSelect.value!=='local' && state.turn===2) setTimeout(()=>computerMove(),200);
      return;
    }
    state.selected=null; updateUI();
  } else {
    // select if own
    if(state.mode==='alkk' ? cellVal===state.turn : (cellVal && cellVal.o===state.turn)){ state.selected=[r,c]; updateUI(); }
  }
}

function inside(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS }

// --- ALKKA rules ---
function alkka_moves(r,c){ const owner=state.grid[r][c]; if(!owner) return [];
  const moves=[]; const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  for(const [dr,dc] of dirs){ const nr=r+dr,nc=c+dc; if(inside(nr,nc) && state.grid[nr][nc]===0) moves.push([nr,nc]);
    const jr=r+2*dr,jc=c+2*dc; if(inside(jr,jc) && state.grid[jr][jc]===0 && state.grid[nr] && state.grid[nr][nc] && state.grid[nr][nc]!==owner) moves.push([jr,jc]); }
  return moves;
}

// --- CHESS rules (basic, no castling/en-passant/promotion minimal) ---
function chess_moves(r,c){ const p=state.grid[r][c]; if(!p) return [];
  const moves=[]; const dirsOrth=[[1,0],[-1,0],[0,1],[0,-1]]; const dirsDiag=[[1,1],[1,-1],[-1,1],[-1,-1]];
  const addIf=(nr,nc)=>{ if(!inside(nr,nc)) return; const t=state.grid[nr][nc]; if(!t) moves.push([nr,nc]); else if(t.o!==p.o) moves.push([nr,nc]); };
  if(p.t==='P'){ const dir = p.o===1?-1:1; // p1 moves up
    const nr=r+dir; if(inside(nr,c) && !state.grid[nr][c]) moves.push([nr,c]); // capture
    for(const dc of [-1,1]){ const nc=c+dc; if(inside(nr,nc) && state.grid[nr][nc] && state.grid[nr][nc].o!==p.o) moves.push([nr,nc]); }
    return moves;
  }
  if(p.t==='N'){ const jumps=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]; for(const [dr,dc] of jumps){ const nr=r+dr,nc=c+dc; if(inside(nr,nc) && (!state.grid[nr][nc] || state.grid[nr][nc].o!==p.o)) moves.push([nr,nc]); } return moves; }
  if(p.t==='K'){ for(const [dr,dc] of dirsOrth.concat(dirsDiag)){ addIf(r+dr,c+dc); } return moves; }
  if(p.t==='R'){ for(const [dr,dc] of dirsOrth){ let nr=r+dr,nc=c+dc; while(inside(nr,nc)){ if(!state.grid[nr][nc]) moves.push([nr,nc]); else { if(state.grid[nr][nc].o!==p.o) moves.push([nr,nr]); break; } nr+=dr; nc+=dc; } } return moves; }
  if(p.t==='B'){ for(const [dr,dc] of dirsDiag){ let nr=r+dr,nc=c+dc; while(inside(nr,nc)){ if(!state.grid[nr][nc]) moves.push([nr,nc]); else { if(state.grid[nr][nc].o!==p.o) moves.push([nr,nc]); break; } nr+=dr; nc+=dc; } } return moves; }
  if(p.t==='Q'){ return chess_moves_sliding(r,c,dirsOrth.concat(dirsDiag)); }
  return moves;
}
function chess_moves_sliding(r,c,dirs){ const moves=[]; for(const [dr,dc] of dirs){ let nr=r+dr,nc=c+dc; while(inside(nr,nc)){ if(!state.grid[nr][nc]) moves.push([nr,nc]); else { if(state.grid[nr][nc].o!==state.grid[r][c].o) moves.push([nr,nc]); break; } nr+=dr; nc+=dc; } } return moves; }

function legalMoves(r,c){ if(state.mode==='alkk') return alkka_moves(r,c); else return chess_moves(r,c); }

function performMove(sr,sc,tr,tc){ if(state.mode==='alkk'){
    // if jump, remove middle
    if(Math.abs(sr-tr)===2||Math.abs(sc-tc)===2){ const mr=(sr+tr)/2|0, mc=(sc+tc)/2|0; state.grid[mr][mc]=0; }
    state.grid[tr][tc]=state.grid[sr][sc]; state.grid[sr][sc]=0; return;
  }
  // chess: capture/normal move
  state.grid[tr][tc]=state.grid[sr][sc]; state.grid[sr][sc]=null;
}

function animateMove(sr,sc,tr,tc){ const from = queryCell(sr,sc); const to = queryCell(tr,tc); if(!from||!to) return; const p = from.querySelector('.piece'); if(!p) return;
  p.classList.add('jump-anim'); setTimeout(()=>p.classList.remove('jump-anim'),300);
}

function pushHistory(){ state.history.push(JSON.parse(JSON.stringify({grid:state.grid,turn:state.turn,selected:state.selected}))); if(state.history.length>60) state.history.shift(); }
function undo(){ if(state.history.length===0) return; const s=state.history.pop(); state.grid=s.grid; state.turn=s.turn; state.selected=s.selected; render(); }

function checkGameOver(){ // simple checks
  if(state.mode==='alkk'){
    const cnt=[0,0,0]; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) cnt[state.grid[r][c]]++;
    if(cnt[1]===0||cnt[2]===0){ const w=cnt[1]>0?1:2; alert('플레이어 '+w+' 승리!'); }
    return;
  }
  // chess: check if king missing
  let k1=0,k2=0; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ const p=state.grid[r][c]; if(p && p.t==='K') p.o===1?k1++:k2++; }
  if(k1===0||k2===0){ alert('플레이어 '+(k1?1:2)+' 승리!'); }
}

// --- AI (very simple) ---
function computerMove(){ if(opponentSelect.value==='local') return; const difficulty=opponentSelect.value; // easy: random legal; hard: greedy capture
  const moves=[];
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ const p=state.grid[r][c]; if(!p) continue; const owner = (state.mode==='alkk')? p: p.o; if(owner!==2) continue; const mvs = legalMoves(r,c); for(const mv of mvs) moves.push({from:[r,c],to:mv}); }
  if(moves.length===0) { log('컴퓨터 이동할 수 없음'); return; }
  let choice;
  if(difficulty==='easy'){ choice = moves[Math.floor(Math.random()*moves.length)]; }
  else {
    // greedy: prefer captures (chess) or jumps (alkk)
    const scored = moves.map(mv=>{ const [tr,tc]=mv.to; let score=0; const target = state.mode==='alkk'? state.grid[(mv.from[0]+tr)/2|0]?.[(mv.from[1]+tc)/2|0] : state.grid[tr][tc]; if(target && target!==0) score+=10; // capture
      // small mobility bonus
      score += legalMoves(mv.to[0],mv.to[1]).length*0.1; return {...mv,score}; });
    scored.sort((a,b)=>b.score-a.score); choice = scored[0];
  }
  pushHistory(); performMove(choice.from[0],choice.from[1],choice.to[0],choice.to[1]); animateMove(choice.from[0],choice.from[1],choice.to[0],choice.to[1]); state.turn=1; render(); checkGameOver(); log('컴퓨터가 이동했습니다');
}

function log(txt){ const d=document.createElement('div'); d.textContent = '['+new Date().toLocaleTimeString()+'] '+txt; logEl.prepend(d); }

// controls
resetBtn.addEventListener('click', ()=>{ pushHistory(); initGrid(); state.turn=1; state.selected=null; render(); log('초기화'); });
undoBtn.addEventListener('click', ()=>{ undo(); log('되돌리기'); });
hintBtn.addEventListener('click', ()=>{ // show one recommended move for current player (greedy)
  const moves=[]; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ const p=state.grid[r][c]; if(!p) continue; const owner = (state.mode==='alkk')? p: p.o; if(owner!==state.turn) continue; for(const mv of legalMoves(r,c)) moves.push({from:[r,c],to:mv}); }
  if(moves.length===0){ log('힌트 없음'); return; }
  // pick best (capture first)
  let best = moves[0]; for(const mv of moves){ const [tr,tc]=mv.to; const mid = state.mode==='alkk'? state.grid[(mv.from[0]+tr)/2|0]?.[(mv.from[1]+tc)/2|0] : state.grid[tr][tc]; if(mid) { best=mv; break; } }
  // highlight
  state.selected = best.from; render(); const el=queryCell(best.to[0],best.to[1]); if(el) el.classList.add('highlight'); log('힌트 표시');
});

modeSelect.addEventListener('change', ()=>{ boot(); }); opponentSelect.addEventListener('change', ()=>{ render(); });

window.addEventListener('keydown', e=>{ if(e.key==='z') undo(); if(e.key==='r'){ pushHistory(); initGrid(); render(); } });

boot();
</script></body>
</html>
